/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2006 STZ-IDA, Germany, http://www.stz-ida.de
     2006 Derrell Lipman

   License:
     LGPL: http://www.gnu.org/licenses/lgpl.html
     EPL: http://www.eclipse.org/org/documents/epl-v10.php
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * Andreas Junghans (lucidcake)
     * Derrell Lipman (derrell)

************************************************************************ */

/**
 * Provides a Remote Procedure Call (RPC) implementation.
 *
 * Each instance of this class represents a "Service". These services can
 * correspond to various concepts on the server side (depending on the
 * programming language/environment being used), but usually, a service means
 * a class on the server.
 *
 * In case multiple instances of the same service are needed, they can be
 * distinguished by ids. If such an id is specified, the server routes all
 * calls to a service that have the same id to the same server-side instance.
 *
 * When calling a server-side method, the parameters and return values are
 * converted automatically. Supported types are int (and Integer), double
 * (and Double), String, Date, Map, and JavaBeans. Beans must have a default
 * constructor on the server side and are represented by simple JavaScript
 * objects on the client side (used as associative arrays with keys matching
 * the server-side properties). Beans can also be nested, but be careful not to
 * create circular references! There are no checks to detect these (which would
 * be expensive), so you as the user are responsible for avoiding them.
 *
 * A simple example:
 * <pre class='javascript'>
 *   function callRpcServer ()
 *   {
 *     var rpc = new qx.io.remote.Rpc();
 *     rpc.setTimeout(10000);
 *     rpc.setUrl("http://127.0.0.1:8007");
 *     rpc.setServiceName("qooxdoo.admin");
 *
 *     // call a remote procedure -- takes no arguments, returns a string
 *     var that = this;
 *     this.RpcRunning = rpc.callAsync(
 *       function(result, ex, id)
 *       {
 *         that.RpcRunning = null;
 *         if (ex == null) {
 *             alert(result);
 *         } else {
 *             alert("Async(" + id + ") exception: " + ex);
 *         }
 *       },
 *       "fss.getBaseDir");
 *   }
 * </pre>
 * __fss.getBaseDir__ is the remote procedure in this case, potential arguments
 * would be listed after the procedure name.
 * <p>
 * Passing data from the client (qooxdoo) side is demonstrated in the
 * qooxdoo-contrib project RpcExample. There are three ways to issue a remote
 * procedure call: synchronously (qx.io.remote.Rpc.callSync -- dangerous
 * because it blocks the whole browser, not just your application, so is
 * highly discouraged); async with results via a callback function
 * (qx.io.remote.Rpc.callAsync) and async with results via an event listener
 * (qx.io.remote.Rpc.callAsyncListeners).
 * <p>
 * You may also find the server writer's guide helpful:
 *   http://manual.qooxdoo.org/${qxversion}/pages/communication/rpc_server_writer_guide.html
 *
 * @ignore(qx.core.ServerSettings.*)
*/


qx.Class.define("componente.general.ramon.io.rpc.Rpc",
{
  extend : qx.io.remote.Rpc,
  construct : function (url, serviceName)
  {
	this.base(arguments, url, serviceName);

	qx.io.remote.Rpc.CONVERT_DATES = true;
	qx.io.remote.Rpc.RESPONSE_JSON = true;
  },
  members : 
  {

    /**
     * Internal RPC call method
     *
     * @lint ignoreDeprecated(eval)
     *
     * @param args {Array}
     *   array of arguments
     *
     * @param callType {Integer}
     *   0 = sync,
     *   1 = async with handler,
     *   2 = async event listeners
     *
     * @param refreshSession {Boolean}
     *   whether a new session should be requested
     *
     * @return {var} the method call reference.
     * @throws {Error} An error.
     */
    _callInternal : function(args, callType, refreshSession)
    {
      var self = this;
      var offset = (callType == 0 ? 0 : 1);
      var whichMethod = (refreshSession ? "refreshSession" : args[offset]);
      var handler = args[0];
      var argsArray = [];
      var eventTarget = this;
      var protocol = this.getProtocol();

      for (var i=offset+1; i<args.length; ++i)
      {
        argsArray.push(args[i]);
      }

      var req = this.createRequest();

      // Get any additional out-of-band data to be sent to the server
      var serverData = this.getServerData();

      // Create the request object
      var rpcData = this.createRpcData(req.getSequenceNumber(),
                                       whichMethod,
                                       argsArray,
                                       serverData);

      req.setCrossDomain(this.getCrossDomain());

      if (this.getUsername())
      {
        req.setUseBasicHttpAuth(this.getUseBasicHttpAuth());
        req.setUsername(this.getUsername());
        req.setPassword(this.getPassword());
      }

      req.setTimeout(this.getTimeout());
      var ex = null;
      var id = null;
      var result = null;
      var response = null;

      var handleRequestFinished = function(eventType, eventTarget)
      {
        switch(callType)
        {
          case 0: // sync
            break;

          case 1: // async with handler function
            handler(result, ex, id);
            break;

          case 2: // async with event listeners
            // Dispatch the event to our listeners.
            if (!ex)
            {
              eventTarget.fireDataEvent(eventType, response);
            }
            else
            {
              // Add the id to the exception
              ex.id = id;

              if (args[0])      // coalesce
              {
                // They requested that we coalesce all failure types to
                // "failed"
                eventTarget.fireDataEvent("failed", ex);
              }
              else
              {
                // No coalese so use original event type
                eventTarget.fireDataEvent(eventType, ex);
              }
            }
        }
      };

      var addToStringToObject = function(obj)
      {
        if (protocol == "qx1")
        {
          obj.toString = function()
          {
            switch(obj.origin)
            {
              case qx.io.remote.Rpc.origin.server:
                return "Server error " + obj.code + ": " + obj.message;

              case qx.io.remote.Rpc.origin.application:
                return "Application error " + obj.code + ": " + obj.message;

              case qx.io.remote.Rpc.origin.transport:
                return "Transport error " + obj.code + ": " + obj.message;

              case qx.io.remote.Rpc.origin.local:
                return "Local error " + obj.code + ": " + obj.message;

              default:
                return ("UNEXPECTED origin " + obj.origin +
                        " error " + obj.code + ": " + obj.message);
            }
          };
        }
        else // protocol == "2.0"
        {
          obj.toString = function()
          {
            var             ret;

            ret =  "Error " + obj.code + ": " + obj.message;
            if (obj.data)
            {
              ret += " (" + obj.data + ")";
            }

            return ret;
          };
        }
      };

      var makeException = function(origin, code, message)
      {
        var ex = new Object();

        if (protocol == "qx1")
        {
          ex.origin = origin;
        }
        ex.code = code;
        ex.message = message;
        addToStringToObject(ex);

        return ex;
      };

      req.addListener("failed", function(evt)
      {
        var code = evt.getStatusCode();
        ex = makeException(qx.io.remote.Rpc.origin.transport,
                           code,
                           qx.io.remote.Exchange.statusCodeToString(code));
        id = this.getSequenceNumber();
        handleRequestFinished("failed", eventTarget);
      });

      req.addListener("timeout", function(evt)
      {
        this.debug("TIMEOUT OCCURRED");
        ex = makeException(qx.io.remote.Rpc.origin.local,
                           qx.io.remote.Rpc.localError.timeout,
                           "Local time-out expired for "+ whichMethod);
        id = this.getSequenceNumber();
        handleRequestFinished("timeout", eventTarget);
      });

      req.addListener("aborted", function(evt)
      {
        ex = makeException(qx.io.remote.Rpc.origin.local,
                           qx.io.remote.Rpc.localError.abort,
                           "Aborted " + whichMethod);
        id = this.getSequenceNumber();
        handleRequestFinished("aborted", eventTarget);
      });

      req.addListener("completed", function(evt)
      {
        response = evt.getContent();

        // server may have reset, giving us no data on our requests
        if (response === null)
        {
          ex = makeException(qx.io.remote.Rpc.origin.local,
                             qx.io.remote.Rpc.localError.nodata,
                             "No data in response to " + whichMethod);
          id = this.getSequenceNumber();
          handleRequestFinished("failed", eventTarget);
          return;
        }

        // Parse. Skip when response is already an object
        // because the script transport was used.
        if (!qx.lang.Type.isObject(response)) {

          // Handle converted dates
          if (self._isConvertDates()) {

            // Parse as JSON and revive date literals
            if (self._isResponseJson()) {
              response = qx.lang.Json.parse(response, function(key, value) {
                if (value && typeof value === "string") {
                	/*
                  if (value.indexOf("new Date(Date.UTC(") >= 0) {
                    var m = value.match(/new Date\(Date.UTC\((\d+),(\d+),(\d+),(\d+),(\d+),(\d+),(\d+)\)\)/);
                    return new Date(Date.UTC(m[1],m[2],m[3],m[4],m[5],m[6],m[7]));
                  }
                  */
                  
					if (value.substr(4, 1) == "-" && value.substr(7, 1) == "-" && (value.length == 10 || value.length == 19)) {
						var m = [];
						m[1] = parseInt(value.substr(0, 4));
						m[2] = parseInt(value.substr(5, 2)) - 1;
						m[3] = parseInt(value.substr(8, 2));
						if (value.length == 19) {
							m[4] = parseInt(value.substr(11, 2));
							m[5] = parseInt(value.substr(14, 2));
							m[6] = parseInt(value.substr(17, 2));
						} else {
							m[4] = 0;
							m[5] = 0;
							m[6] = 0;
						}
						
						return new Date(m[1],m[2],m[3],m[4],m[5],m[6]);
					}
                }
                return value;
              });

            // Eval
            } else {
              response = response && response.length > 0 ? eval('(' + response + ')') : null;
            }

          // No special date handling required, JSON assumed
          } else {
            response = qx.lang.Json.parse(response);
          }
        }

        id = response["id"];

        if (id != this.getSequenceNumber())
        {
          this.warn("Received id (" + id + ") does not match requested id " +
                    "(" + this.getSequenceNumber() + ")!");
        }

        // Determine if an error was returned. Assume no error, initially.
        var eventType = "completed";
        var exTest = response["error"];

        if (exTest != null)
        {
          // There was an error
          result = null;
          addToStringToObject(exTest);
          ex = exTest;

          // Change the event type
          eventType = "failed";
        }
        else
        {
          result = response["result"];

          if (refreshSession)
          {
            result = eval("(" + result + ")");
            var newSuffix = qx.core.ServerSettings.serverPathSuffix;

            if (self.__currentServerSuffix != newSuffix)
            {
              self.__previousServerSuffix = self.__currentServerSuffix;
              self.__currentServerSuffix = newSuffix;
            }

            self.setUrl(self.fixUrl(self.getUrl()));
          }
        }

        handleRequestFinished(eventType, eventTarget);
      });

      // Provide a replacer when convert dates is enabled
      var replacer = null;
      if (this._isConvertDates()) {
        replacer = function(key, value) {
          // The value passed in is of type string, because the Date's
          // toJson gets applied before. Get value from containing object.
          value = this[key];

          if (qx.lang.Type.isDate(value)) {
          	/*
            var dateParams =
              value.getUTCFullYear() + "," +
              value.getUTCMonth() + "," +
              value.getUTCDate() + "," +
              value.getUTCHours() + "," +
              value.getUTCMinutes() + "," +
              value.getUTCSeconds() + "," +
              value.getUTCMilliseconds();
            return "new Date(Date.UTC(" + dateParams + "))";
            */
            
	        var dateParams =
	          value.getFullYear() + "-" +
	          qx.lang.String.pad((value.getMonth() + 1).toString(), 2, "0") + "-" +
	          qx.lang.String.pad(value.getDate().toString(), 2, "0") + " " +
	          qx.lang.String.pad(value.getHours().toString(), 2, "0") + ":" +
	          qx.lang.String.pad(value.getMinutes().toString(), 2, "0") + ":" +
	          qx.lang.String.pad(value.getSeconds().toString(), 2, "0");
	        return dateParams;
          }
          return value;
        };
      }

      req.setData(qx.lang.Json.stringify(rpcData, replacer));
      req.setAsynchronous(callType > 0);

      if (req.getCrossDomain())
      {
        // Our choice here has no effect anyway.  This is purely informational.
        req.setRequestHeader("Content-Type",
                             "application/x-www-form-urlencoded");
      }
      else
      {
        // When not cross-domain, set type to text/json
        req.setRequestHeader("Content-Type", "application/json");
      }

      // Do not parse as JSON. Later done conditionally.
      req.setParseJson(false);

      req.send();

      if (callType == 0)
      {
        if (ex != null)
        {
          var error = new Error(ex.toString());
          error.rpcdetails = ex;
          throw error;
        }

        return result;
      }
      else
      {
        return req;
      }
    }
		
  }
});